#include<iostream>

/******
[포인터, Pointer]
- 포인터는 '주소'를 저장하는 변수
- 시존에 사용하던 변수는 데이터를 저장하는 데에 반하여, 포인터는 메모리 공간의 주소를 저장한다.
- 포인터 변수가 주소를 저장하려면 변수의 주소를 알아야한다.
- 변수 이름 앞에 & 연산자를 붙이면 해당 변수의 시작 주소를 반환한다.
- 또한 포인터 변수가 저장하는 변수의 주소에 저장된 값을 참조 하려면 * 연산자를 이용한다.
- 
[포인터 연산자]
& : 특정 데이터의 메모리 상의 주소값을 알 수 있다.
* : & 연산자가 어떠한 데이터의 주소값을 얻어내는 연산자라면, 이것은 거꾸로 
   주소값에서 해당 데이터를 가져오는 연산자가 필요한데, 그 역할을 수행한다.

[포인터 정의방법]
(포인터에 주소값이 저장되는 데이터형)* (포인터의 이름)

******/
using namespace std;
int main() {
	// 일반 변수
	// int a = 1;

	//int* p;
	//int a = 5;
	//p = &a;
	//int b = *p;

	//cout << "a에 저장된 값 :" << a << endl;
	//cout << "a의 주소값 : " << &a << endl;
	//cout << "p에 저장된 값 - a의 주소값 : " << p << endl;
	//cout << "b에 저장된 값 - p에 저장돼 있는 a의 주소값에서 역참조한 값 (a) : " << b << endl;
	//cout << "포인터 변수 p의 주소값 : " << &p << endl;

	//*p = 512;
	//cout << "역참조를 통해 변경한 a의 값" << a << endl;

	int num = 10;
	int* p = &num;

	int** pp;
	pp = &p;

	cout << "포인터 변수 p" << p << endl;
	cout << "포인터 변수 p의 주소값" << pp << endl;

	**pp = 1234;
	cout << "2번의 역참조로 바꾼 num의 값" << num << endl;

	// 아무것도 가리키지 않는다.
	// int* ptr = nullptr;

	int* ptr = new int(42); // 동적 메모리 할당. ptr은 동적 메모리에 할당 된 주소를 가리킨다.

	cout << "동적 할당된 값" << *ptr << endl;
	cout << "해제 전 ptr의 주소" << ptr << endl;
	delete ptr;

	cout << "해제 후 ptr의 주소" << ptr << endl;

	ptr = nullptr;
	cout << "null 포인터로 안전하게 초기화." << ptr << endl;

	// 댕글링? 포인터
	// 이미 해제된 메모리의 주소값을 들고 있는 포인터
	// 스마트 포인터.(참조)
	// 메모리 단편화 (참조)
}