#include<iostream>
using namespace std;
/*
포인터 배열
- 말 그대로 포인터들의 배열 (배열의 각 요소가 포인터)
- 배열의 타입을int, chqr 등등으로 하듯이, 배열의 타입을 int*로 선언
- 즉, 배열의 각각의 원소는 int를 가리키는 포인터 형으로 선언
- 따라서 int 배열에서 각각의 원소를 int형 변수로 취급했던 것 처럼 int*배열에서
각각의 요소를 int형 변수를 가리키는 포인터로 취급

*/

// 만약 배열을 받아서 두 숫자를 더하는 함수를 만든다면

int AddNum(int number[]) {
	
	return number[0] + number[1];
}

int main() {
	int num[] = {1, 2};
	int res = AddNum(num);
	// 포인터 배열
	int* arr[3];

	int num1 = 1;
	int num2 = 2;
	int num3 = 3;

	// arr[0] = 3; >> 안됨

	arr[0] = &num1;
	arr[1] = &num2;
	arr[2] = &num3;

	cout << "num1 :" << num1 << ", " << *arr[0] << endl;
	cout << "num2 :" << num2 << ", " << *arr[1] << endl;
	cout << "num3 :" << num3 << ", " << *arr[2] << endl;

	cout << &num1 << "   " << arr[0] << endl;
	///////////////////////////////////////////////////////////////////////////
	cout << endl << endl;
	/*
	배열포인터
	- 배열의 첫번째 요소를 가리키는 포인터
	- 배열의 이름은 배열의 첫번째 요소의 주소이므로 배열포인터를 사용하면 배열 요소에 쉽게 접근할 수 있다.

	[배열의 이름과 첫번째 요소와의 관계]
	- 배열의 이름은 첫번째 원소를 가리키는 포인터라고 할수있나?
	- 배열의 이름은 첫번째 원소의 주소와 같지만 배열의 이름 자체는 포인터가 아님.
	- 배열은 배열자체의 데이터 구조 이고 포인터는 메모리 주소를 가리키기 때문.
	- 배열의 이름을 사용할 때 암묵적으로 배열의 첫번째 원소를 가리키는 포인터로 타입 변환 됨.
	- 즉, 배열의 이름을 포인터 처럼 사용할 수 있지만 다른개념이다.
	*/

	int arr1[10] = { 1,2,3,4,5,6,7,8,9,10 };
	int* pArr;
	pArr = arr1; // 배열의 시작 주소를 저장.

	for (int i = 0; i < 10; i++) {
		cout <<"@@@" << "arr[" << i << "]의 주소값" << &arr1[i] << "  ";
		cout << "(pArr" << i << ")의 값" << pArr + 1 << "  ";

		if (&arr1[i] == (pArr + i)) {
			cout << "일치" << endl;
		}
		else {
			cout << "불일치" << endl;
		}
	}

	///////////////////////////////////////////////
	/*
	상수 포인터
	- 상수 포인터는 두가지 방식으로 사용.
	1. 포인터 자체가 상수인 경우
	- 포인터가 가리키는 주소를 변경할 순 없지만, 그 주소에 저장된 값은 변경가능.
	2. 포인터가 가리키는 값이 상수인 경우.
	- 포인터가 가리키는 주소에 저장 된 값은 변경할 순 없지만, 주소 자체는 변경이 가능함.
	
	*/

	// 포인터 상수
	int num = 10;
	// int* const ptr = &num;
	*ptr = 30; // ptr이 가리키는 값은 변경 가능
	int otherNum = 5;

	// ptr이 다른 주소를 가리키게 할 수 없다.
	// ㄴ ptr = &otherNum; 
	cout << *ptr << endl;

	// 상수 포인터
	int val = 10;
	const int* ptr1 = &val;

	// *ptr1 = 6; 불가능
	ptr1 = &otherNum;
	
	cout << *ptr << endl;
	// 과제
	/*
	트럼프 카드 52장

	스페이드 A ~ K
	다이아 A ~ K
	하트 A ~ K
	클로버 A ~ K

	비교를 할건데..

	1. 카드는 위와 같이 52장이 있다.
	2. 플레이어가 있다.
	3. 딜러가 있다
	
	게임조건
	- 딜러는  3장의 카드를 보여준다.
	ex) 스페이드 A(1), 다이아 7, 클로버 8(치트키)
	- 플레이어는 베팅을 한다.
	- 이기는 조건은 (베팅한 금액의 *2)
	-ㄴ 첫번째 카드와 두번째 카드 사이에 세번째 카드가
	-ㄴ 범위안에 있다. 그러면 승리
	-ㄴ 예시는 패배. 범위에 걸치더라도 패배로 간주함.
	
	종료조건
	- 보유액이 최소베팅 금액보다 적을 때.
	- 한번 사용한 카드는 다시 사용할 수 없음.
	- 13판 후 종료
	- 특정 확률로 잭팟. 
	*/
}